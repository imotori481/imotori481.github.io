<!DOCTYPE html>
<html lang="JA">
    <head>
        <meta charset="utf-8" />
        <title>いもとりのページ</title>
        <link rel="icon" href="../images/imotori_fx.png" type="image/png" />
        <link href="../styles/style.css" rel="stylesheet">
    </head>
    <body>
        <div class="bg_gen"></div>
        <div class="main">
            <h1>いもとりのページ</h1>
            <a href="../index.html">ホームに戻る</a>
            <h2>一般</h2>
            <p>どうでもいいことを好きなだけ書く場所です。
                <br>まあ、開発の話がほとんどになるでしょうけど...
            </p>
            <h3>目次</h3>
            <!--TEMPLATE
                <li><a href="#yyyymmdd">yyyy/mm/dd </a></li>
            -->
                <li><a href="#20250615">2025/06/15 OS自作8</a></li>
                <li><a href="#20250608">2025/06/08 OS自作7</a></li>
                <li><a href="#20250601">2025/06/01 OS自作6</a></li>
                <li><a href="#20250526">2025/05/26 OS自作5</a></li>
                <li><a href="#20250520">2025/05/20 OS自作4</a></li>
                <li><a href="#20250516">2025/05/16 OS自作3</a></li>
                <li><a href="#20250511">2025/05/11 OS自作2</a></li>
                <li><a href="#20250507">2025/05/07 OS自作1</a></li>
                <li><a href="#20250506">2025/05/06 OS自作をしよう（唐突）</a></li>
                <li><a href="#20250104">2025/01/04 今日も今日とて京都へ</a></li>
                <li><a href="#20241214">2024/12/14 ProjectCの進捗 対戦編</a></li>
            <br>
            <!--本文-->
            <ul>
                <!--TEMPLATE
                <li id="yyyymmdd">yyyy/mm/dd </li>
                <p>
                    <div class="indent_img">
                        <img src="../images/" alt="" width="60%" height="60%">
                    </div>
                </p>
                <br>
                -->

                <li id="202506015">2025/06/15 OS自作8</li>
                <p>メモリ管理を実装します。
                    <br>私の中で、メモリ管理はOS最大の役目だと考えています。
                    <br>なぜなら30年ITエンジニアやってる人に「OSは基本メモリ管理しかやってねえんだよ」と言われたからです（思考放棄）
                    <br>実際、ちゃんとメモリ管理をしてやらないと、使用中の領域に関係ないデータが書き込まれたりして大変です。
                    <p>ここで久しぶりにメモリマップの登場です。1か月ぶり？
                        <br>メモリマップの情報はUEFIが持っているので、KernelMainの引数にとってやれば問題ありません。
                        <br>メモリマップの構造体を用意し、それのポインタをKernelMainで渡し、表示させる...という流れですね
                        <br>表示させるとこんな感じ
                    </p>
                    <div class="indent_img">
                        <img src="../images/g_20250615.png" alt="" width="60%" height="60%">
                    </div>
                    <p>OSは命令に応じてメモリ領域を割り当てたり、使用中の領域を避けたりしてメモリを管理します。
                        <br>UEFIにはメモリ区画の用途に応じてメモリタイプが定義されており、これをチェックすることで空き領域かどうか判断します。
                        <br>画面に書かれているtype3, 4はUEFIを抜けたら自由に使っていい領域。7はOSが自由に使っていい領域です。
                        <br>これら3つだった場合、使用可能だと判断するIsAvailable関数を用意します。
                    </p>
                    <p>データ構造をOSが所有するメモリ領域へ移動させます。
                        <br>移動させるのは、プログラムの実行に使うスタック領域、メモリを区画に分けるGDT（Global Descriptor Table）、メモリを固定長に分割するページテーブルの3つです。
                        <br>これらのデータ構造は、起動時にブートローダ専用データ領域（kEftBootServiceData）、番号で言うと4番ですね。
                        <br>さっき言った通り、4番はIsAvailable関数が使用可能と判断します。つまり、この領域は他のデータに上書きされる可能性があるのです。
                        <br>なぜここを使用可能メモリと扱ってしまったのか、ｺﾚｶﾞﾜｶﾗﾅｲ。
                    </p>
                    <p>3つも解説してたら長くなるので短めに</p>
                    <p>まずはスタックを移動させます。
                        <br>レジスタのひとつであるRSPには、スタックの先頭アドレス（8バイト）が入っています。
                        <br>スタックはアドレスの上から下に積まれるため、Pushする度にRSPはどんどん小さくなります。
                        <br>何が言いたいのかと言うと、RSPの初期値をメモリ領域の末尾に置けばいい、という訳です。
                        <br>カーネルのプログラムに新しいスタック領域となる配列(要素数1024 * 1024)を用意してあげましょう。
                    </p>
                    <p>次はセグメンテーション。
                        <br>セグメンテーションに必要なデータ構造はGDTで、ディスクリプタという8バイトのデータ構造を並べた配列です。
                        <br>GDTは、SegmentDescriptorを要素として3つ持つ配列を、グローバル変数gbtとして宣言します。
                        <br>セグメントディスクリプタの構造体を用意し、この構造体に値を設定しGDTを再構築する関数SetupSegmentsを実装します。
                        <br>0番目に0、1番目にコードセグメントディスクリプタ、2番目にデータセグメントディスクリプタに設定してLoadGDT関数を呼び出せば、変数gdtをCPUに登録できます。
                        <br>LoadGDTでは、アセンブリでlimit（GDTのバイト数）とoffset（GDTの先頭アドレス）の10バイト分の領域をlgdt命令で受け取り、その値をGDTR（GDT Register）に設定します。
                        <br>GDTRが切り替わったら終わりではなく、隠し領域にセグメントディスクリプタが残っています。
                        <br>これはGDTRを書き換える際の不具合を防いでくれますが、最終的にこの部分も書き換えます。
                        <br>セグメンテーション、本当はもっと複雑な手順を踏んでいるのですが、まともに理解できる内容ではないのでここには書きません。いや、書けません（これを書くのに休日が半分消えている！）
                     </p>
                     <p>さいごにページング。
                        <br>仮想アドレスと物理アドレスを変換する機能を持ち、やろうと思えば複雑な変換もできます。
                        <br>今回はシンプルな物理・仮想ともにアドレスを一致させるアイデンティティマッピングができるようにします。
                        <br>ここまで理解するまでに時間が掛かったことが気に入らず、何度も本で顔を叩き続けたせいでページが破れそうです。
                        <br>ページングは4層になっており、ページマップレベル4テーブル（PML4table）、ページディレクトリポインタテーブル（PDPtable）、ページディレクトリ、ページテーブルという構成になっています。
                        <br>この構成を実装し、PML4テーブルの物理アドレスをCR3レジスタに設定すれば、用意した階層ページング構造が使えるようになります。
                     </p>
                     <p>これでようやく下準備も終わり、メモリ管理の実装が始まります。
                        <br>メモリマネージャは書籍では、ページフレーム（物理アドレス上の区画）を1ページフレームあたり1ビットで管理する方式である、ビットマップを採用しています。
                        <br>BitmapMemoryManagerクラスで実装するのは
                        <br>・1ページフレームを1ビットで表したビットマップであるalloc_map_
                        <br>・何もしないとメモリマネージャが物理メモリは無限にあると勘違いするため、メモリ割り当てを行う範囲を決めるrange_begin_とrange_end_
                        <br>・初期状態ではメモリ領域全体を未使用と判定するため、使用中の領域を伝えるMarkAllocated関数
                        <br>・ビットの読み書きを行うGetBitとSetBit関数
                        <br>・メモリ割り当てと解放
                        <p>最も大事なのはメモリ割り当てと解放ですね。
                            <br>メモリの割り当て方には、指定されたメモリの要求量以上の未使用領域を探索し、その位置を返すfrist fitという方法があります。
                            <br>書籍ではこれをAllocate関数として実装することになります。
                            <br>割り当てるページフレームの数を渡して、range_begin_から探索し、見つかり次第その領域を使用中にし、先頭アドレスを返します。
                            <br>また、Free関数は指定したフレームの範囲を返却します。
                        </p>
                        <p>メモリ管理、OS自作でも特に難しい要素でした。
                            <br>次回は重ね合わせ処理を実装していきます。
                        </p>
                     </p>
                </p>
                <br>

                <li id="20250608">2025/06/08 OS自作7</li>
                <p>x86-64アーキテクチャでの割り込みを実装します。
                    <br>低レイヤに限らずとも、ソフトウェア開発者なら誰もが耳にするであろう割り込み（Interrupt）
                    <br>かなり削って説明すると、イベントが発生した際に、ハードウェアがOSに通知し処理する、というものです。
                    <br>前回はポーリングで常にマウスの状態を監視していましたが、マウスは不定期に動作するため監視し続けるのはCPUの無駄使いになります。
                    <br>割り込みではマウスが操作されたときだけイベントを発生させるため、ポーリングと比べると効率が良いです。
                    <br>そして何より、今後他の周辺機器やシステムコールが増えても、CPUを無駄なく使えるからですね。
                    <p>割り込みを行うには、イベント発生時の処理である割り込みハンドラを書く必要があります。と言っても、気にするべきはたった2つ。</p>
                    <p>・関数の定義の前に __attribute__((interrupt)) と書くこと。
                        <br>→コンパイラに割り込みハンドラと認識してもらうため。
                    </p>
                    <p>・割り込みハンドラの最後にEnd of Interruptレジスタに0を書き込むこと。
                        <br> →割り込みが終了したと伝えるため。こうしないと次の割り込みハンドラが呼び出されない。
                        <br> レジスタと言っても、CPUではなくメモリの一部（1024バイト）をレジスタとして使用している。
                    </p>後はいつも通りC++の関数を書くノリで問題ないです。
                    <br>
                    <br>
                    <p>割り込みベクタについても。
                        <br>まず、割り込みは色々あります。
                        <br>外部割り込み（入出力、タイマー...）、内部割り込み（ゼロ除算、不正なメモリ書込み...）、これらをただの割り込みと一括りにするのは愚かです。
                        <br>そのため、割り込みの種類に応じて番号を割り当てる...これが割り込みベクタです。
                    </p>
                    <p>しかし、番号を割り当てるだけではいけません。
                        <br>割り込みベクタに対応する割り込みハンドラを割り当てなければなりません（あと何回、割って書けばいいんだろう...）
                        <br>N番の割り込みが発生したら、この割り込みハンドラを実行する...という情報が必要になります。
                        <br>この関係を表にしたのがIDT（Interrupt Descriptor Table）、割り込み記述子テーブルです。
                        <br>0~255までの割り込みベクタと、割り込みハンドラのアドレスが対応しており、これにより異なる割り込みハンドラを呼び出すことができます。
                    </p>
                    <p>ここまでで割り込みが発生してから実行されるまでの実装はできました。
                        <br>しかし、肝心の割り込みが発生する部分ができていません。
                        <br>xHCIでの割り込み発生には、MSI（Message Signaled Interrupts）を利用します。
                        <br>特定のメモリアドレス（Message Address）に32ビットの値を書き込み、CPUに割り込みを通知する、という流れです。
                        <br>Message Addressには、割り込みを通知するCPUコアの番号や、割り込みベクタ番号などを指定します。
                        <br>これで割り込みが発生してくれます。
                        <br>ここまでの仕組みは複雑に見えますが、流れさえ分かれば処理のイメージがしやすいと思います。ちなみに私はイメージできません。
                    </p>
                    <p>これで割り込みは完成...ではありません。
                        <br>今のままでは、割り込み処理が長引いた場合、他の割り込みを取りこぼす可能性があります。
                        <br>そのため、割り込みハンドラの高速化を行いましょう。
                    </p>
                    <p>書籍では、割り込みが発生したことを記録するキューを用意し、そこから取り出して...を空になるまで繰り返す方法を実装します。
                        <br>キュー（Queue）とは、先入れ先出し（FIFO）と呼ばれるデータ構造で、配列などの先頭からデータを順に格納（Push, Enqueue）し、先頭から取り出す（Pop, Dequeue）、という2つの操作でデータを管理します。
                        <br>キューが用いられる場面として、プリンターの印刷ジョブやネットワーク通信、テトリスのネクストなどがあります。
                        <br>キューについて長々と話すのも趣旨がズレるので、使う際の注意点だけ確認しておきます。
                        <br>それは、キューの操作中にCPUの割り込みフラグを0にしておくことです。0の間、CPUは外部割り込みを受け取らなくなります。
                        <br>こうしないと、別の割り込みが発生した際に、キューが想定と異なる操作が行われ、データ競合が起こる可能性があります。
                        <br>最後に、キューの操作が終了したら割り込みレジスタを1に戻してあげましょう。
                    </p>
                    <p>
                        見た目は変わりませんが、やや動作が軽くなったような気がする？？
                    </p>
                    <div class="indent_img">
                        <img src="../images/g_20250608.png" alt="" width="60%" height="60%">
                    </div>
                    <p>ちょっと駆け足になってしまいましたが、これで割り込みは完成です。
                        <br>割り込みはかなり重要な処理なので、本当はもっと詳しく書くべきなんでしょうが、今の私にはこれが限界でした。
                        <br>次回はメモリ管理を行います。
                    </p>
                    
                </p>
                <br>

                <li id="20250601">2025/06/01 OS自作6</li>
                <p>マウスに対応させます。
                    <br>まずはカーソルだけ表示させましょう。
                    <br>二次元配列にマウスカーソルの絵を格納します。
                    <br>このとき配列の要素数は、Null文字を格納するために横幅を1つ多めに確保する必要があります。
                    <br>ついでに長方形を描画する関数も用意されていたので、OSらしく画面を少し手を加えてみましょう。
                    <div class="indent_img">
                        <img src="../images/g_20250601.png" alt="" width="60%" height="60%">
                    </div>
                    <p>ここからが本番？
                        <br>USB（Universal Serial Bus）、多分この世で最も有名なシリアル通信規格に対応させます。書籍ではUSB 3.xへの対応を目指します。
                        <br>そもそもシリアル通信とは、一本の信号線を用いた通信のことで、パラレル通信の対になる存在です。
                        <br>かつてはパラレル通信で一度に多くの情報を送るのが強力とされていましたが、通信の整合性を取るのが難しいという欠点があります。
                        <br>だから、1本の線だけで済むシリアル通信の方が一般的になったんですね。
                        <br>有名どころとしてUARTやSPI、modの名前みたいなI2Cなんかもあり...と、大して詳しくもないのに語ってボロが出ても嫌なのでこれくらいで。
                    </p>
                    <p>ついにUSBドライバの実装を...と思いましたが、書籍には著者が用意したドライバを使ってとしか書かれていません。
                        <br>察してはいましたが、USBドライバの実装はあまりにも過酷とのことで、解説すら載っていません。
                        <br>コードはあるので、試しにドライバがどのように実装されているのか確認したのですが、理解するには永遠より永い時間が必要そうです。
                        <br>（さっきシリアル通信の話で時間稼ぎしてたのは、ここで書くことがないからなんですね、はい）
                    </p>
                    <p>一番重要そうな所をすっ飛ばす羽目になりましたが、次へ行きましょう。
                        <br>PCI（Peripheral Component Interconnect）という規格をご存じでしょうか。私はPCO（Perfect Clear Opener）しか知りません。
                        <br>これは周辺機器とマザーボードをと通信するための規格で、現在はPCIeという後継規格もあります（互換性あり）
                        <br>PCIバスに接続されているPCIデバイスを読み込み、USB3.xのホストコントローラの規格であるxHCI（eXtensible Host Controller Interface）に準拠したxHCを探索します。
                        <br>ここでのOSの役割は、PCIコンフィギュレーション空間という256バイトの領域を読み取り、どのようなデバイスが接続されているかを把握します。
                    </p>
                    <div class="indent_img">
                        <img src="../images/g_20250601-2.png" alt="" width="60%" height="60%">
                    </div>
                    <p>ここではっきり言わせてください。私はもう何が起きているのか全然分かりません。
                        <br>こんな調子では、自力で基本ソフトウェアの設計なんて夢のまた夢です。
                        <br>ハードウェアに弱すぎるが故（あたかもソフトなら分かるかのような発言）に、どうも理解に時間が掛かりそうです。
                    </p>
                    <p>とにかくマウスの実装を進めましょう
                        <br>ポーリングでマウスの動きを監視します。
                        <br>ポーリングは常に周辺機器の状態を監視するので、マウスのようなデバイスでは効率が悪いとされていますが、一旦これで実装することになります。
                        <br>こちらもまたコードが複雑ですが、どうにか流れだけでも追ってみます。
                    </p>
                    <p>まず、PCIからxHCを探すところからです。PCIが認識できる限界までループして探索します。
                        <br>見つけたxHCを初期化し、動作を開始させます。動作が開始すると、PCに接続されたUSBデバイスを認識します。
                        <br>USBマウスが認識されたら、今度はマウスからデータを受信し、マウスを動かした分だけ画面上でも動かします。
                        <br>実際に動かしてみると...
                    </p>
                    <div class="indent_img">
                        <img src="../images/g_20250601-3.png" alt="" width="60%" height="60%">
                    </div>
                    <p>ようやく動いたかと思えば、移動後の塗りつぶしが悪さをしてこのザマです。
                        <br>これは書籍の内容を進めれば改善されるのですが、しばらくはこの状態になりそうです。
                        <br>なんとなく、どう改善するのかは分かるような気がします、読んでないから知らんけど。
                    </p>
                    <p>次回は割り込みの実装を行います。</p>
                </p>
                <br>

                <li id="20250526">2025/05/26 OS自作5</li>
                <p>文字の描画をやっていきます。
                    <br>前回使用したピクセルを描画する関数を利用＆文字データを用意して描画します。
                    <br>どう文字データを実装するのかと思ったら、まさかの配列に8ビットデータを突っ込む形でした。
                    <br>書籍では"A"だけ描画するサンプルがあります。
                    <div class="indent_img">
                        <img src="../images/g_20250526.png" alt="" width="60%" height="60%">
                    </div>
                    <p>さすがにこれを全部作るのは過酷なので、<a href="http://openlab.ring.gr.jp/efont/shinonome/">東雲フォント</a>を使用することになっていました。
                    <br>こちらを読み込ませると、無事に文字が使えるようになります。
                    <br>文字列を引数で渡して描画する関数も用意します。
                    <br>他にもprintfのような書式整形付きの関数も欲しいですが、標準ライブラリのNewlibから、sprintfで代用することに。
                    <br>NewlibはOSの依存度が低いらしいですが、その代わりに動的メモリ管理や入出力周りの一部は自分で実装しなければなりません。セルフサービスです。
                    <br>Newlibのヘッダーファイルをインクルードして、sprintfを使うと、書式整形付きの文字列が描画できるようになります。
                    <div class="indent_img">
                        <img src="../images/g_20250526-2.png" alt="" width="60%" height="60%">
                    </div>
                    <p>まだまだやります。
                        <br>Linuxではカーネルコンソールに出力する関数であるprintkを模した関数を作ります。
                        <br>こちらも可変長の引数を受け取る関数で、printfと同じように書式整形ができるようになっています。
                    </p>
                    <div class="indent_img">
                        <img src="../images/g_20250526-3.png" alt="" width="60%" height="60%">
                    </div>
                    <p> これがあれば、ログ出力も容易になり開発が楽になることでしょう。
                        <br>次回はマウス入力を実装します。
                    </p>
                </p>
                <br>

                <li id="20250520">2025/05/20 OS自作4</li>
                <p>makeだったり描画だったりをやっていきます。
                    <br>書籍にあるmakeのサンプルを実行しようとしたのですが、インクルード出来ねえよハゲと一蹴されてしまいました。
                    <br>これも前回と同じく<a href="https://github.com/uchan-nos/os-from-zero/issues/82">Issue</a>が立っていたので、そちらを参考にして実行できるようにしました。
                    <p>Makefileは完全に初見ですが、これを機に書き方だけちょっと見てきました（本当に見ただけ）
                        <br>コンパイル時のコマンドをまとめてくれるのは間違いなく便利なので、ここや別の環境でも慣れておきたい所です。
                    </p>
                    <p>さて、Makefileの話はここまでにして、描画をやってみましょう。
                        <br>前回まではフレームバッファに直接値を書き込んでいましたが、人間にはあまりにも使いづらいので手を加えます。
                        <br>UEFIにはピクセルデータを扱う規格が4つもあるのですが、書籍ではその内の扱いやすい2つを利用します。
                        <br>1つはRGBと座標を指定してピクセルを描画し、もう一つはBGRを指定します（順番変わっただけでは...?）
                        <br>歴史的な理由でBGRもあるらしいですが、個人的にRGBの方が分かりやすいのでそちらを使います。
                    </p>

                    <h3>・Graphics Output Protocol</h3>
                    <p>UEFIが提供するグラフィック描画プロトコル
                        <br>今回はPixelRedGreenBlueReserved8BitPerColorという規格を使用します。
                        <br>光の三原色でおなじみのRGB（+予約領域 or αチャンネル）を8ビットずつ使うフォーマットです。
                        <br>この規格は最も描画が楽で、ピクセル単位で1つずつ色を付けていきます。
                        <br>中には、一度にバッファに情報を格納してから、一気に描画する方法もありますが、実装がとても大変と聞いているためやってません。
                    </p>
                    <br>

                    <p>早速main.cppに描画用クラスを用意し、そこに座標や色を指定して描画できるメンバ関数を実装します。
                        <br>書籍に緑色の長方形を描くサンプルがあったので、これを実行してみます。
                    </p>
                    <div class="indent_img">
                        <img src="../images/g_20250520.png" alt="" width="60%" height="60%">
                    </div>
                    <p>無事に描画されましたね。
                    </p>
                    <p>せっかくなので、私も何か描いてみましょう。
                        <br>私がよく使っている山岳積み二号です。
                        <br>どう考えてもこんなのやってる暇ねえだろというツッコミは受け付けておりません。
                    </p>
                    <div class="indent_img">
                        <img src="../images/g_20250520-2.png" alt="" width="60%" height="60%">
                    </div>
                    <p>次回は文字の描画を行います。</p>
                </p>
                <br>

                <li id="20250516">2025/05/16 OS自作3</li>
                <p>ブートローダやカーネルを作成していきます。

                    <h3>・カーネル</h3>
                    <p>ハードウェアの資源管理、ハードウェアとソフトウェアを仲介するプログラム
                        <br>UEFIの規格通り作る必要があるが、ブートローダーからカーネルを呼び出す形式にすることで、その制約を回避します。
                        <br>
                        <br>コマンド例（Clang++ & LLD）
                        <blockquote>
                            <p>$ clang++ -O2 -Wall -g --target=x86_64-elf -ffreestanding -mno-red-zone -fno-exceptions -fno-rtti -std=c++17 -c main.cpp
                                <br>ld.lld --entry KernelMain -z norelro --image-base 0x100000 --static -o kernel.elf main.o
                            </p>
                        </blockquote>
                        <p>カーネルを読み込む際は、UEFIのOpen関数でkernel.elfを読み込み、GetInfo関数でファイル情報を取得します。
                            <br>GetInfoの4番目の引数が特殊で、EFI_FILE_INFO型の構造体が入るだけのメモリ領域を指定するのですが、ただ指定するだけではいけません。
                            <br>実は、ここにはelfファイルに付けた名前を格納する必要もあり、その名前の文字数分メモリを多めに確保しなければなりません。
                            <br>今回のkernel.elfはsizeof(CHAR16) * 12バイトだけ多く確保しています。
                        </p>
                    </p>

                    <br>まずはmain.cppに特に何も起こらないだけのカーネルを書きます。
                    <br>名前修飾やインラインアセンブラといった初見の要素ばかりですが、この書き方にも少しずつ慣れていかねば。
                    <br>コンパイルとリンクが終わるとkernel.elfファイルが生成されます。
                    <p>ブートローダでもカーネルを読み込めるように、Main.cも修正します。
                        <br>カーネルを配置する番地を指定したり、ファイルを読み込めるようにメモリを確保したりします。
                        <br>ビルドしてQEMUで起動して、無事に動けば成功です。
                    </p>
                    <p>このときは気づいていなかったのですが、私がここで作ったカーネルは正常に動作していませんでした。
                        <br>どうやら書籍では、リンカはLLVM-7の使用を前提としており、LLD10では動作しないようです。
                        <br>LLVM-7は古いため、Ubuntu20.04にすらデフォルトで入っておらず、わざわざダウングレー
                        <br>ドしなければなりません。
                    </p>
                    <p>この件については公式のGitHubに<a href="https://github.com/uchan-nos/os-from-zero/issues/168">Issue</a>が立っていたため、そちらを参考にしました。
                        <br>バージョン違いでのエラーは別界隈で慣れていましたが、自作OSでも同じ目に遭うとは...油断しました。
                    </p>
                    <p>この事実に気づかず私が次にやっていたのは、ブートローダ上で画面を白く塗り潰す命令でした。
                        <br>こちらは特に問題なく動作します、カーネルを使ってる訳ではないので。
                    </p>
                    <div class="indent_img">
                        <img src="../images/g_20250516.png" alt="" width="60%" height="60%">
                    </div>
                    <p>次はカーネルを使って、画面をグラデーションのように塗りつぶす命令を作ります。
                        <br>しかし、なぜか命令を書いても画面が白いままです。
                        <br>それもそのはず、あなた、リンカのバージョンを間違えてますよ？
                        <br>これに気づかず何時間も四苦八苦していました。もう少し早くIssueを見ていれば...。
                        <br>
                        <br>四苦八苦と言ったら一つネタを思いつきました。
                        <p><strong>テトリスは、四楽八苦</strong>（これが通じる人は、もう立派なTGMプレイヤーです）</p>
                    <p>そんな冗談はさておき、リンカのバージョンを直してからカーネルをビルドし直すと、ちゃんとグラデーションが表示されました。</p>
                    <div class="indent_img">
                        <img src="../images/g_20250516-2.png" alt="" width="60%" height="60%">
                    </div>
                    <p>最後に、簡易的なエラー処理を実装しましょう。
                        <br>といっても単純なもので、ブートローダ上でエラーメッセージの表示をするだけです。
                        <br>あと無限ループを呼び出して無理やり実行を止める感じですかね。
                    </p>
                    <p>次回は画面に絵を描く命令を実装していきます。
                    </p>
                </p>
                <br>

                <li id="20250511">2025/05/11 OS自作2</li>
                <p>EDK IIやメモリについての話です。最初だから仕方ないけど地味な要素が多い...。
                    <p>どうやらEDK2（II表記は面倒なので2でいいよね）はUEFI BIOSや、そのUEFI BIOS上で動くアプリの開発ができるとのこと。
                        <br>開発環境は書籍の付録に付いているGitHubのリンクがあるので、そこからダウンロー
                        <br>ドすることができます。
                    </p>

                    <h3>・EDK2</h3>
                    <p>EFI Development Kit II、最近色々と話題のIntel製のUEFIファームウェアとかアプリの開発環境。
                        <br>EDK2のフォルダの中身を見てみると、その中には大量のフォルダが！全部見てたらキリがないです。
                        <br>大事なのはedksetup.shとMdePkgでしょうかね？
                        <br>前者はビルド環境をセットアップするためのスクリプトで、後者はUefi.hとかが入ってるフォルダです。
                        <br>Uefi.hもインクルードの連続で見るのが億劫になります。お前らどんだけヘッダーファイルあるんだ。
                        <br>他にもLibraryフォルダのUefiLib.hも追っていたら時間がいくらあっても足りません。こっちは1Fも無駄にできないんだ。
                        <br>一応、書籍の付録にedk2のファイル説明の一部が載っているのですが、正直ここに載せるほどのことは書いていません。気になるなら本買って見てくれ（ダイマ）
                    </p>

                    <h3>・メモリマップ</h3>
                    <p>メインメモリのどこが・何に・どれだけ使われているかを確認できる。
                        <br>もし既に使われているアドレスにデータを置こうものなら、当然死は免れられません。
                        <br>ありがたいことに、BIOSにはメモリマップを確認する機能があります。
                        <br>ブートサービスを表すグローバル変数gBSを使い、GetMemoryMapという関数を呼び出すことで確認できます。
                        <br>なお、GetMemoryMapは、OSがUEFIの制御を離れる前（ExitBootServicesの直前）に呼ぶのが一般的です。
                    </p>

                    <h3>・UEFI BIOS</h3>
                    <p>Unified Extensible Firmware Interface、Basic Input/Output System
                        <br>OSを起動するため、つまりブートローダを読み出す機能。
                        <br>UEFI BIOSとBIOSは別物ですが、今回はUEFIという表現で統一。
                        <br>細かいことを言うと、UEFIはハードウェアを動かす役割のファームウェアの仕様を定めたものであり、プログラムではありません。
                        <br>しかしOS作りの素人がこんなのを気にしていては埒があきません。BIOSみたいなもんだと認識させていただきます。
                        <br>UEFIのプログラムは.efiという形式にして実行されます。適切にコンパイル&リンクしてあげれば生成されます。
                        <br>
                        <br>コマンド例（Clang & LLD）
                        <blockquote>
                            <p>$ clang -target x86_64-pc-win32-coff -mno-red-zone -fno-stack-protector -fshort-wchar -wall -c "ファイル名".c
                                <br>$ lld-link /subsystem:efi_application /entry:"関数名" /out:"ファイル名".efi "ファイル名".o
                            </p>
                        </blockquote>
                        <p>coff形式で.oファイルを作成 → PE形式で実行ファイル（Windowsの.exeもPE形式）作成という流れですね。
                        </p>
                    </p>
                    <br>

                    <p>では、EDK2を用いてHello, World!をやってみます。実行結果だけ見たらほぼ再放送です。
                        <br>Main.cには、EDK2フォルダ内にあるヘッダーファイルをincludeしてからプログラムを書きます。
                        <br>普段のC言語との違いは、最初に実行されるのはmain関数ではなく、Loader.infファイルにENTRY_POINTという項目があり、そこで設定した名前がmain関数の代わりになる所でしょうか？
                        <br>あとprintfは使わず、Uefi.hで定義されているPrint関数を使うみたいです。一応printfとほぼ同じ挙動をするのでそこまで違和感はないです。
                    </p>
                    <p>他にも機能を実装しましょう。今回はメモリマップをcsvファイルに書き込む機能を作ります。
                        <br>書籍にはコードの解説も載っているのですが、それ以上にポインタの解説が多いです。
                        <br>やはりポインタは難しいので、著者も念入りに教えておきたいのでしょう...（まずポインタ分からん人は他の内容も大丈夫なのか？という疑問も残りますが）
                    </p>
                    <p>完成したらビルドして起動します。
                        <br>ちゃんと起動するまで結構ミスりました...根気がないとやってられん作業ですねえ。
                    </p>
                    <div class="indent_img">
                        <img src="../images/g_202505010.png" alt="" width="60%" height="60%">
                    </div>
                    <p>出力されたcsvファイルも確認してみましょう。
                        <br>アドレスが表示されまくってます。1つくらい勝手に使ってもバレへんかな。
                    </p>
                    <div class="indent_img">
                        <img src="../images/g_202505010-2.png" alt="" width="60%" height="60%">
                    </div>
                    <p>次回はブートローダを作成し、いよいよOS本体にも手を出していきます。
                    </p>
                </p>
                <br>

                <li id="20250507">2025/05/07 OS自作1</li>
                <p>環境構築からHello, World!までを試してみました。
                    <br>まず開発環境について、最初はWSL2とUbuntu24.04を使おうと思ったのですが、<a href="https://github.com/uchan-nos/mikanos-build">これ</a>
                        を見る限り非推奨らしいのでUbuntu20.04を別で用意しました。
                    <br>Ubuntu上にディスクイメージを用意してQEMUで起動する、という流れでHello, World!まで進めます。
                    <br>C言語でやるのかなと思いきや、最初だけなぜかバイナリエディタで書かされました、飛鳥時代でもこんなんやらんぞ。
                    <br>
                    <br>作ったバイナリファイルをさっき作ったディスクイメージに読み込ませてから起動すると...
                    <div class="indent_img">
                        <img src="../images/g_02050507.png" alt="" width="60%" height="60%">
                    </div>
                    <p>なんとHello, World!が表示されたではありませんか！どうなってんだこれ（無知）
                        <br>仕組みは追々調べるとして、とりあえず起動は成功です。
                        <br>次回はUEFI用の開発キット EDK IIを試します。
                    </p>
                </p>
                <br>
                
                <li id="20250506">2025/05/06 OS自作をしよう（唐突）</li>
                <p>大学でソフトウェア系の授業を担当している教授が、技術を身につけるための活動をしていると聞いて参加してみました。
                    <br>参加者は7,8人ほど（しかも全員知り合い）で、自由に何でもやっていい感じの雰囲気でした。
                    <br>せっかくの機会なので、私は無謀にもOSの自作に挑戦することにしました。
                    <br>何があっても逃げられないように速攻で内田公太氏の「ゼロからのOS自作入門」を購入。
                    <br>ここに色々書いているのも逃げ場を塞ぐ一環でございます。
                </p>
                <p>正直なところ、私一人の力だけで完成させられる気がしません。
                    <br>去年までポインタで苦しんでいたような人間に出来るのでしょうか...?
                </p>
                <p>しかし今回はありがたいことに、心強い味方が大勢います！
                    <br>電子系・情報系の学生と教授がサポートしてくれるのです。こんないい環境が他にあるというのか。
                    <br>というか、これだけ協力者がいるのに諦めるのは無理です。裏切るわけにいかん...。
                </p>
                <p>目標としては、2か月以内での完成を目指しています。
                    <br>今回使う書籍では1か月が目標とされていますが、他のメンバーとの折り合い&これとは別の活動で多忙なため、ある程度余裕は持たせておきます。
                    <br>果たしてOSは完成するのか？ すべては明日の私にかかっている！
                </p>
                <br>
                <li id="20250104">2025/01/04 今日も今日とて京都へ</li>
                <p>本日は高校の友人たちと北野天満宮まで行って参りました。
                    <br>流石に4日なので人はそこまで多くなかったです。
                    <div class="indent_img">
                        <img src="../images/g-20250104-2.JPG" alt="北野天満宮" width="60%" height="60%">
                    </div>
                    <br>テトリスが上手くなるのを願って、賽銭は20円にしました。
                    <br>延命長寿のお守りも買っておきました。Moddedマイクラやテトリスは時間がいくらあっても足りないので...。
                </p>
                <p>近くにうまいラーメン屋もありました。
                    <div class="indent_img">
                        <img src="../images/g_20250104.jpg" alt="みそラーメン" width="60%" height="60%">
                    </div>
                    <br>偏食なので、ラーメン食う時は毎回みそを注文してます。
                </p>
                <p>京都に来たついでにa-choでTGMをしましたが、Shirase S8という残念な結果に...。
                    <br>次来たときはS12まで行きたいですね。
                </p>
                <br>

                <li id="20241214">2024/12/14 ProjectCの進捗 対戦編</li>
                <p>11月から開発を進めているProjectCですが、3割くらい完成したので報告だけしておきます。
                    <br>某対戦アクションパズルゲームのような何かですね。
                    <div class="indent_img">
                        <img src="../images/g_20241214.png" alt="対戦容認中" width="60%" height="60%">
                    </div>
                    <br>今のところローカル環境でのみ対戦可能。
                    <br>操作はTGM、対戦はテトエフェ寄りの仕様を目指しています。
                    <br>RENテーブルはテトリスの歴史を見て、独自のものを使用することにしました。
                    <blockquote>
                    2~5REN   +1
                    <br>6~10REN  +2 
                    <br>11~16REN +3
                    <br>17~REN   +4
                    </blockquote>
                    今後もテストプレイを重ねてバランス調整しようと思います。
                </p>    
            </ul>
            <a href="../index.html">ホームに戻る</a>
        </div>
    </body>
</html>